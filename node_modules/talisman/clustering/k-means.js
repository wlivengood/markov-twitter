'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KMeans = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Talisman clustering/k-means
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ============================
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Function related to k-means clustering.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * [Reference]: https://en.wikipedia.org/wiki/K-means_clustering
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


exports.default = kMeans;

var _euclidean = require('../metrics/distance/euclidean');

var _euclidean2 = _interopRequireDefault(_euclidean);

var _vectors = require('../helpers/vectors');

var _random = require('../helpers/random');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Default options for k-means clustering.
 */
var DEFAULTS = {
  k: 8,
  distance: _euclidean2.default,
  maxIterations: 300,
  initialCentroids: null,
  sampler: _random.sample
};

/**
 * Helpers.
 */
function compareCentroids(a, b) {
  for (var i = 0, l = a.length; i < l; i++) {
    for (var j = 0, m = a[i].length; j < m; j++) {
      if (a[i][j] !== b[i][j]) return false;
    }
  }

  return true;
}

/**
 * KMeans class used to fine tune the clustering when needed & handling
 * the internal state of the process.
 *
 * @constructor
 * @param {array}          data                       - Array of vectors.
 * @param {object}         options                    - Possible options:
 * @param {number}         [options.k]                - Number of clusters.
 * @param {function}       [options.distance]         - Distance function.
 * @param {number}         [options.maxIterations]
 *   - Maximum number of iterations.
 * @param {array|function} [options.initialCentroids]
 *   - Either an array of initial centroids or a function computing them.
 * @param {function}       [options.sampler]          - Sampling function.
 */

var KMeans = exports.KMeans = function () {
  function KMeans(data) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, KMeans);

    // Enforcing data validity
    if (!Array.isArray(data)) throw Error('talisman/clustering/k-means: dataset should be an array of vectors.');

    // Properties
    this.data = data;
    this.dimensions = this.data[0].length;
    this.iterations = 0;
    this.centroids = null;
    this.previousCentroids = null;
    this.clusters = null;

    // Options
    this.k = options.k || DEFAULTS.k;
    this.distance = options.distance || DEFAULTS.distance;
    this.maxIterations = options.maxIterations || DEFAULTS.maxIterations;
    this.sampler = options.sampler || DEFAULTS.sampler;

    // Enforcing correct options
    if (typeof this.k !== 'number' || this.k <= 0) throw Error('talisman/clustering/k-means: `k` should be > 0.');

    if (this.data.length < this.k) throw Error('talisman/clustering/k-means: k is greater than the number of provided vectors.');

    if (typeof this.distance !== 'function') throw Error('talisman/clustering/k-means: the `distance` option should be a function.');

    if (typeof this.maxIterations !== 'number' || this.maxIterations <= 0) throw Error('talisman/clustering/k-means: the `maxIterations` option should be > 0.');

    if (typeof this.sampler !== 'function') throw Error('talisman/clustering/k-means: the `sampler` option should be a function.');

    // Computing initial centroids
    var initialCentroids = options.initialCentroids;

    if (initialCentroids) {

      // The user is giving the initial centroids:
      if (typeof initialCentroids === 'function') initialCentroids = initialCentroids(this.data, {
        k: this.k,
        distance: this.distance,
        maxIterations: this.maxIterations
      });
    } else {

      // Else, we're gonna choose the initial centroids randomly
      initialCentroids = this.sampler(this.k, this.data);
    }

    // Ensuring the starting centroids are correct
    if (!Array.isArray(initialCentroids)) throw Error('talisman/clustering/k-means: `initialCentroids` are not an array or the function you provided to compute them returned invalid data (could be your `sampler`).');

    if (initialCentroids.length !== this.k) throw Error('talisman/clustering/k-means: you should provide k centroids (got ' + initialCentroids.length + ' instead of ' + this.k + ').');

    if (!initialCentroids.every(function (centroid) {
      return Array.isArray(centroid) && centroid.length === _this.dimensions;
    })) throw Error('talisman/clustering/k-means: at least one of the provided or computed centroids is not of the correct dimension.');

    this.centroids = initialCentroids;
  }

  /**
   * Method used to perform one iteration of the clustering algorithm.
   *
   * @return {KMeans} - Returns itself for chaining.
   */


  _createClass(KMeans, [{
    key: 'iterate',
    value: function iterate() {

      // If the clustering has already converged, we break
      if (this.converged) return this;

      // Initializing the clusters
      this.clusters = new Array(this.k);
      var vectorMap = new Map();

      for (var i = 0; i < this.k; i++) {
        this.clusters[i] = [];
      } // Iterating through the dataset's vectors
      for (var _i = 0, l = this.data.length; _i < l; _i++) {
        var vector = this.data[_i];

        // Finding the closest centroid
        var min = Infinity,
            minIndex = 0;

        for (var j = 0, m = this.dimensions; j < m; j++) {
          var d = this.distance(vector, this.centroids[j]);

          if (d < min) {
            min = d;
            minIndex = j;
          }
        }

        // Pushing the vector in the correct cluster
        this.clusters[minIndex].push(vector);
        vectorMap.set(vector, minIndex);
      }

      // If any of the clusters is empty, we fill it with a random vector.
      var displacedVectors = [];

      for (var _i2 = 0, _l = this.k; _i2 < _l; _i2++) {
        var cluster = this.clusters[_i2];

        if (!cluster.length) {
          var _vector = this.sampler(1, this.data)[0];
          cluster.push(_vector);
          displacedVectors.push(_vector);
        }
      }

      // Now we need to remove the potentially displaced vectors their origin
      for (var _i3 = 0, _l2 = displacedVectors.length; _i3 < _l2; _i3++) {
        var _vector2 = displacedVectors[_i3],
            _cluster = this.clusters[vectorMap.get(_vector2)],
            index = _cluster.indexOf(_vector2);

        _cluster.splice(index, 1);
      }

      // We now find the new centroids
      this.previousCentroids = this.centroids;
      this.centroids = new Array(this.k);

      for (var _i4 = 0, _l3 = this.k; _i4 < _l3; _i4++) {
        this.centroids[_i4] = (0, _vectors.mean)(this.clusters[_i4]);
      }this.iterations++;

      // Checking if the clustering has converged
      this.converged = compareCentroids(this.previousCentroids, this.centroids);

      return this;
    }

    /**
     * Method used to start the clustering process.
     *
     * @return {array} - The resulting clusters.
     */

  }, {
    key: 'run',
    value: function run() {

      // While we don't converge or haven't performed the allowed iterations:
      while (!this.converged && this.iterations < this.maxIterations) {
        this.iterate();
      }return this.clusters;
    }
  }]);

  return KMeans;
}();

/**
 * Exporting a convenient function to perform simple k-means clustering.
 *
 * @param  {object} options - Clustering options.
 * @param  {array}  data    - Target dataset.
 * @param  {array}          - Resulting clusters.
 */


function kMeans(options, data) {
  var clustering = new KMeans(data, options);

  return clustering.run();
}