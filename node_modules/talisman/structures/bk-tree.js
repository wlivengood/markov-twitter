'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Talisman structure/bk-tree
 * ===========================
 *
 * Implementation of a Buckhard-Keller tree, allowing fast lookups of words
 * that lie within a specified distance of the query word.
 *
 * [Reference]:
 * https://en.wikipedia.org/wiki/BK-tree
 *
 * [Article]:
 * W. Burkhard and R. Keller. Some approaches to best-match file searching,
 * CACM, 1973
 */

/**
 * Helper used to insert a word in the tree.
 *
 * @param {function} distance - Distance function to use.
 * @param {object}   tree     - Target tree.
 * @param {string}   word     - Word to insert.
 */
function insertWord(distance, tree, word) {
  var d = distance(word, tree.word);

  if (d in tree.children) insertWord(distance, tree.children[d], word);else tree.children[d] = { word: word, children: {} };
}

/**
 * Helper used to search for words in the tree.
 *
 * @param {function} distance - Distance function to use.
 * @param {object}   tree     - Target tree.
 * @param {string}   word     - Word to query.
 * @param {number}   n        - Max distance.
 * @param {array}    acc      - Accumulator.
 */
function searchWord(distance, tree, word, n, acc) {
  var d = distance(word, tree.word);

  if (d <= n) acc.push(tree.word);

  for (var i = d - n, l = d + n + 1; i < l; i++) {
    var children = tree.children[i];

    if (children) {
      searchWord(distance, children, word, n, acc);
    }
  }
}

/**
 * The BKTree class.
 *
 * @constructor
 * @param {function} distance - Distance function to be used by the tree.
 * @param {array}    words    - Initial words.
 */

var BKTree = function () {
  function BKTree(distance, words) {
    _classCallCheck(this, BKTree);

    if (typeof distance !== 'function') throw Error('talisman/structure/bk-tree.constructor: given distance is not a function.');

    if (words && !Array.isArray(words)) throw Error('talisman/structure/bk-tree.constructor: given words are not an array.');

    // Properties
    this.distance = distance;
    this.tree = null;

    if (words) {
      for (var i = 0, l = words.length; i < l; i++) {
        this.add(words[i]);
      }
    }
  }

  /**
   * Method used to add the given word into the tree.
   *
   * @param  {string} word - Word to add.
   * @return {BKTree}      - Returns itself for chaining.
   */


  _createClass(BKTree, [{
    key: 'add',
    value: function add(word) {

      // Initializing the tree with first given word:
      if (!this.tree) {
        this.tree = { word: word, children: {} };
        return this;
      }

      // Else, we properly add the word in the tree
      insertWord(this.distance, this.tree, word);

      return this;
    }

    /**
     * Method used to search all words in the tree that are within the given
     * distance.
     *
     * @param  {string} word  - Word to query.
     * @param  {number} [n=2] - Maximum distance between query & targets.
     * @return {array}        - Returns an array of near words.
     */

  }, {
    key: 'search',
    value: function search(word) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

      var found = [];

      searchWord(this.distance, this.tree, word, n, found);

      return found;
    }
  }]);

  return BKTree;
}();

exports.default = BKTree;