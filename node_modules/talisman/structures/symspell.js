'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-loop-func: 0 */
/**
 * Talisman structure/symspell
 * ============================
 *
 * JavaScript implementation of the Symmetric Delete Spelling dictionary to
 * efficiently index & query expression based on edit distance.
 * Note that the current implementation target the v3.0 of the algorithm.
 *
 * [Reference]:
 * http://blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/
 * https://github.com/wolfgarbe/symspell
 *
 * [Author]:
 * Wolf Garbe
 */

/**
 * Constants.
 */
var DEFAULT_MAX_DISTANCE = 2,
    DEFAULT_VERBOSITY = 2;

var VERBOSITY = new Set([
// Returns only the top suggestion
0,
// Returns suggestions with the smallest edit distance
1,
// Returns every suggestion (no early termination)
2]);

/**
 * Functions.
 */

/**
 * Function creating a dictionary item.
 *
 * @param  {number} [value] - An optional suggestion.
 * @return {object}         - The created item.
 */
function createDictionaryItem(value) {
  var suggestions = new Set();

  if (typeof value === 'number') suggestions.add(value);

  return {
    suggestions: suggestions,
    count: 0
  };
}

/**
 * Function creating a suggestion item.
 *
 * @return {object} - The created item.
 */
function createSuggestionItem(term, distance, count) {
  return {
    term: term || '',
    distance: distance || 0,
    count: count || 0
  };
}

/**
 * Simplified edit function.
 *
 * @param {string} word      - Target word.
 * @param {number} distance  - Distance.
 * @param {number} max       - Max distance.
 * @param {Set}    [deletes] - Set mutated to store deletes.
 */
function edits(word, distance, max, deletes) {
  deletes = deletes || new Set();
  distance++;

  var l = word.length;

  if (l > 1) {
    for (var i = 0; i < l; i++) {
      var deletedItem = word.substring(0, i) + word.substring(i + 1);

      if (!deletes.has(deletedItem)) {
        deletes.add(deletedItem);

        if (distance < max) edits(deletedItem, distance, max, deletes);
      }
    }
  }

  return deletes;
}

/**
 * Function used to conditionally add suggestions.
 *
 * @param {array}  words       - Words list.
 * @param {number} verbosity   - Verbosity level.
 * @param {object} item        - The target item.
 * @param {string} suggestion  - The target suggestion.
 * @param {number} int         - Integer key of the word.
 * @param {object} deletedItem - Considered deleted item.
 * @param {SymSpell}
 */
function addLowestDistance(words, verbosity, item, suggestion, int, deletedItem) {
  var first = item.suggestions.values().next().value;

  if (verbosity < 2 && item.suggestions.size > 0 && words[first].length - deletedItem.length > suggestion.length - deletedItem.length) {
    item.suggestions = new Set();
    item.count = 0;
  }

  if (verbosity === 2 || !item.suggestions.size || words[first].length - deletedItem.length >= suggestion.length - deletedItem.length) {
    item.suggestions.add(int);
  }
}

/**
 * Custom Damerau-Levenshtein used by the algorithm.
 *
 * @param  {string} source - First string.
 * @param  {string} target - Second string.
 * @return {number}        - The distance.
 */
function damerauLevenshtein(source, target) {
  var m = source.length,
      n = target.length,
      H = [[]],
      INF = m + n,
      sd = new Map();

  H[0][0] = INF;

  for (var i = 0; i <= m; i++) {
    if (!H[i + 1]) H[i + 1] = [];
    H[i + 1][1] = i;
    H[i + 1][0] = INF;
  }

  for (var j = 0; j <= n; j++) {
    H[1][j + 1] = j;
    H[0][j + 1] = INF;
  }

  var st = source + target;

  for (var _i = 0, l = st.length; _i < l; _i++) {
    var letter = st[_i];

    if (!sd.has(letter)) sd.set(letter, 0);
  }

  // Iterating
  for (var _i2 = 1; _i2 <= m; _i2++) {
    var DB = 0;

    for (var _j = 1; _j <= n; _j++) {
      var i1 = sd.get(target[_j - 1]),
          j1 = DB;

      if (source[_i2 - 1] === target[_j - 1]) {
        H[_i2 + 1][_j + 1] = H[_i2][_j];
        DB = _j;
      } else {
        H[_i2 + 1][_j + 1] = Math.min(H[_i2][_j], H[_i2 + 1][_j], H[_i2][_j + 1]) + 1;
      }

      H[_i2 + 1][_j + 1] = Math.min(H[_i2 + 1][_j + 1], H[i1][j1] + (_i2 - i1 - 1) + 1 + (_j - j1 - 1));
    }

    sd.set(source[_i2 - 1], _i2);
  }

  return H[m + 1][n + 1];
}

/**
 * Lookup function.
 *
 * @param  {object} dictionary  - A SymSpell dictionary.
 * @param  {array}  words       - Unique words list.
 * @param  {number} verbosity   - Verbosity level.
 * @param  {number} maxDistance - Maximum distance.
 * @param  {number} maxLength   - Maximum word length in the dictionary.
 * @param  {string} input       - Input string.
 * @return {array}              - The list of suggestions.
 */
function lookup(dictionary, words, verbosity, maxDistance, maxLength, input) {
  var length = input.length;

  if (length - maxDistance > maxLength) return [];

  var candidates = [input],
      candidateSet = new Set(),
      suggestionSet = new Set();

  var suggestions = [];

  // Exhausting every candidates

  var _loop = function _loop() {
    var candidate = candidates.shift();

    // Early termination
    if (verbosity < 2 && suggestions.length > 0 && length - candidate.length > suggestions[0].distance) return 'break';

    var item = dictionary[candidate];

    if (item !== undefined) {
      if (typeof item === 'number') item = createDictionaryItem(item);

      if (item.count > 0 && !suggestionSet.has(candidate)) {
        suggestionSet.add(candidate);

        var suggestItem = createSuggestionItem(candidate, length - candidate.length, item.count);

        suggestions.push(suggestItem);

        // Another early termination
        if (verbosity < 2 && length - candidate.length === 0) return 'break';
      }

      // Iterating over the item's suggestions
      item.suggestions.forEach(function (index) {
        var suggestion = words[index];

        // Do we already have this suggestion?
        if (suggestionSet.has(suggestion)) return;

        suggestionSet.add(suggestion);

        // Computing distance between candidate & suggestion
        var distance = 0;

        if (input !== suggestion) {
          if (suggestion.length === candidate.length) {
            distance = length - candidate.length;
          } else if (length === candidate.length) {
            distance = suggestion.length - candidate.length;
          } else {
            var ii = 0,
                jj = 0;

            var l = suggestion.length;

            while (ii < l && ii < length && suggestion[ii] === input[ii]) {
              ii++;
            }

            while (jj < l - ii && jj < length && suggestion[l - jj - 1] === input[length - jj - 1]) {
              jj++;
            }

            if (ii > 0 || jj > 0) {
              distance = damerauLevenshtein(suggestion.substr(ii, l - ii - jj), input.substr(ii, length - ii - jj));
            } else {
              distance = damerauLevenshtein(suggestion, input);
            }
          }
        }

        // Removing suggestions of higher distance
        if (verbosity < 2 && suggestions.length > 0 && suggestions[0].distance > distance) {
          suggestions = [];
        }

        if (verbosity < 2 && suggestions.length > 0 && distance > suggestions[0].distance) {
          return;
        }

        if (distance <= maxDistance) {
          var target = dictionary[suggestion];

          if (target !== undefined) {
            suggestions.push(createSuggestionItem(suggestion, distance, target.count));
          }
        }
      });
    }

    // Adding edits
    if (length - candidate.length < maxDistance) {

      if (verbosity < 2 && suggestions.length > 0 && length - candidate.length >= suggestions[0].distance) return 'continue';

      for (var i = 0, l = candidate.length; i < l; i++) {
        var deletedItem = candidate.substring(0, i) + candidate.substring(i + 1);

        if (!candidateSet.has(deletedItem)) {
          candidateSet.add(deletedItem);
          candidates.push(deletedItem);
        }
      }
    }
  };

  _loop2: while (candidates.length > 0) {
    var _ret = _loop();

    switch (_ret) {
      case 'break':
        break _loop2;

      case 'continue':
        continue;}
  }

  if (verbosity === 0) return suggestions.slice(0, 1);

  return suggestions;
}

/**
 * The SymSpell class.
 *
 * @constructor
 * @param {object} [options]       - Options:
 * @param {number}   [maxDistance] - Maximum edit distance of index.
 */

var SymSpell = function () {
  function SymSpell(options) {
    _classCallCheck(this, SymSpell);

    options = options || {};

    // Properties
    this.dictionary = Object.create(null);
    this.maxLength = 0;
    this.words = [];
    this.maxDistance = typeof options.maxDistance === 'number' ? options.maxDistance : DEFAULT_MAX_DISTANCE;
    this.verbosity = typeof options.verbosity === 'number' ? options.verbosity : DEFAULT_VERBOSITY;

    // Sanity checks
    if (typeof this.maxDistance !== 'number' || this.maxDistance <= 0) throw Error('talisman/structure/symspell.constructor: invalid `maxDistance` option. Should be a integer greater than 0.');

    if (!VERBOSITY.has(this.verbosity)) throw Error('talisman/structure/symspell.constructor: invalid `verbosity` option. Should be either 0, 1 or 2.');
  }

  /**
   * Method used to add a word to the index.
   *
   * @param {string} word       - Word to add.
   * @param {SymSpell}
   */


  _createClass(SymSpell, [{
    key: 'add',
    value: function add(word) {
      var _this = this;

      var item = this.dictionary[word];

      if (item !== undefined) {
        if (typeof item === 'number') {
          item = createDictionaryItem(item);
          this.dictionary[word] = item;
        }

        item.count++;
      } else {
        item = createDictionaryItem();
        item.count++;

        this.dictionary[word] = item;

        if (word.length > this.maxLength) this.maxLength = word.length;
      }

      if (item.count === 1) {
        (function () {
          var number = _this.words.length;
          _this.words.push(word);

          var deletes = edits(word, 0, _this.maxDistance);

          deletes.forEach(function (deletedItem) {
            var target = _this.dictionary[deletedItem];

            if (target !== undefined) {
              if (typeof target === 'number') {
                target = createDictionaryItem(target);

                _this.dictionary[deletedItem] = target;
              }

              if (!target.suggestions.has(number)) {
                addLowestDistance(_this.words, _this.verbosity, target, word, number, deletedItem);
              }
            } else {
              _this.dictionary[deletedItem] = number;
            }
          });
        })();
      }

      return this;
    }

    /**
     * Method used to search for the desired input.
     *
     * @param  {string} input - Input query.
     * @return {array}        - The found suggestions.
     */

  }, {
    key: 'search',
    value: function search(input) {
      return lookup(this.dictionary, this.words, this.verbosity, this.maxDistance, this.maxLength, input);
    }
  }]);

  return SymSpell;
}();

exports.default = SymSpell;