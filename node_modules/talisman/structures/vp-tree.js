'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Talisman structure/vp-tree
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ===========================
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Implementation of the Vantage Point Tree.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * [Reference]:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * https://en.wikipedia.org/wiki/Vantage-point_tree
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * [Note]:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This implementation does not randomly select a point.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _heap = require('mnemonist/heap');

var _heap2 = _interopRequireDefault(_heap);

var _descriptive = require('../stats/descriptive');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// TODO: implement random for choice? or better, a function to choose

/**
 * Constants.
 */
var SORTER = function SORTER(a, b) {
  if (a.distance < b.distance) return 1;
  if (a.distance > b.distance) return -1;

  return 0;
};

/**
 * Functions use to recursively build the tree.
 *
 * @param  {function} distance - Distance function to use.
 * @param  {array}    items    - Items to store.
 */
function makeTree(distance, items) {
  var tree = {
    vantage: items.pop()
  };

  if (!items.length) return tree;

  // Computing distances
  var distances = new Array(items.length);

  for (var i = 0, l = items.length; i < l; i++) {
    var item = items[i];
    distances[i] = distance(tree.vantage, item);
  }

  tree.mu = (0, _descriptive.median)(distances);

  var left = [],
      right = [];

  for (var _i = 0, _l = items.length; _i < _l; _i++) {
    var d = distances[_i];

    if (d >= tree.mu) right.push(items[_i]);else left.push(items[_i]);
  }

  if (left.length) tree.left = makeTree(distance, left);
  if (right.length) tree.right = makeTree(distance, right);

  return tree;
}

/**
 * Vantage Point Tree class.
 *
 * @constructor
 * @param {function} distance - Distance function.
 * @param {array}    items    - Items to store.
 */

var VPTree = function () {
  function VPTree(distance, items) {
    _classCallCheck(this, VPTree);

    // Validation
    if (typeof distance !== 'function') throw new Error('talisman/structures/vp-tree.constructor: given distance is not a function.');

    if (!Array.isArray(items)) throw new Error('talisman/structures/vp-tree.constructor: invalid items. Should be an array.');

    // Properties
    this.distance = distance;
    this.root = makeTree(distance, items.slice());
  }

  /**
   * Method used to retrieve the k nearest neighbors of query.
   *
   * @param {number} k     - Number of neighbors.
   * @param {any}    query - Query.
   * @param {array}        - Found neighbors.
   */


  _createClass(VPTree, [{
    key: 'nearestNeighbors',
    value: function nearestNeighbors(k, query) {
      var neighbors = new _heap2.default(),
          queue = [this.root];

      neighbors.comparator = SORTER;

      var tau = Infinity;

      while (queue.length > 0) {
        var node = queue.pop();

        var d = this.distance(query, node.vantage);

        if (d < tau) {
          neighbors.push({ distance: d, item: node.vantage });

          // Trimming
          if (neighbors.size > k) neighbors.pop();

          // Adjusting tau
          tau = neighbors.peek().distance;
        }

        if (!node.left && !node.right) continue;

        if (d < node.mu) {
          if (d < node.mu + tau && node.left) queue.push(node.left);
          if (d >= node.mu - tau && node.right) queue.push(node.right);
        } else {
          if (d >= node.mu - tau && node.right) queue.push(node.right);
          if (d < node.mu + tau && node.left) queue.push(node.left);
        }
      }

      var result = new Array(neighbors.size);

      for (var i = neighbors.size - 1; i >= 0; i--) {
        result[i] = neighbors.pop();
      }return result;
    }

    /**
     * Method used to retrieve every neighbors in the given range for the
     * given query.
     *
     * @param {number} range - Range.
     * @param {any}    query - Query.
     * @param {array}        - Found neighbors.
     */

  }, {
    key: 'neighborsInRange',
    value: function neighborsInRange(range, query) {
      var neighbors = [],
          queue = [this.root];

      var tau = range;

      while (queue.length > 0) {
        var node = queue.pop();

        var d = this.distance(query, node.vantage);

        if (d <= tau) neighbors.push({ distance: d, item: node.vantage });

        if (!node.left && !node.right) continue;

        if (d < node.mu) {
          if (d < node.mu + tau && node.left) queue.push(node.left);
          if (d >= node.mu - tau && node.right) queue.push(node.right);
        } else {
          if (d >= node.mu - tau && node.right) queue.push(node.right);
          if (d < node.mu + tau && node.left) queue.push(node.left);
        }
      }

      return neighbors;
    }
  }]);

  return VPTree;
}();

exports.default = VPTree;